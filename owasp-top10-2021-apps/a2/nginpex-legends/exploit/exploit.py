import hashlib
from Crypto.Util.number import long_to_bytes, bytes_to_long, inverse
from ecdsa.ecdsa import generator_256, Private_key, Public_key, Signature

def encode(file, outfile, privkey):
    data = open(file, "rb").read()
    z = bytes_to_long(hashlib.sha256(data).digest())
    sig = privkey.sign(z, 10)
    r = sig.r
    s = sig.s
    r_enc = long_to_bytes(r)
    s_enc = long_to_bytes(s)
    data = bytes([len(r_enc)]) + r_enc + bytes([len(s_enc)]) + s_enc + data
    open(outfile, "wb").write(data)

def getSignature(file):
    data = open(file, "rb").read()
    r_enc = data[1:data[0]+1]
    s_enc = data[2+data[0]:2+data[0]+data[data[0]+1]]
    zfile = data[2+data[0]+data[data[0]+1]:]
    r = bytes_to_long(r_enc)
    s = bytes_to_long(s_enc)
    return Signature(r, s), bytes_to_long(hashlib.sha256(zfile).digest())

g = generator_256
ORDER = g.order()

signature1, z1 = getSignature("patch1")
signature2, z2 = getSignature("patch2")
r = signature1.r
assert(signature2.r == r)
s1 = signature1.s
s2 = signature2.s

for i in [-1, 1]:
    for j in [-1, 1]:
        k = ((z1-z2)%ORDER*inverse(i*s1 + j*s2, ORDER))%ORDER
        invr = inverse(r, ORDER)
        secret = ((((s2*k)%ORDER)-z2)*invr)%ORDER
        pubkey = Public_key( g, g * secret )
        privkey = Private_key( pubkey, secret )
        encode("malware.zip", "malware"+str(i)+str(j), privkey)

